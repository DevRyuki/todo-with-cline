# Guidelines for Task Execution, Test-Driven Development (TDD), and Memory Bank Management

This document outlines clear guidelines for breaking down tasks into subtasks, employing Test-Driven Development (TDD) practices when appropriate, and managing the Memory Bank. Following these guidelines will help ensure consistent, reliable, and high-quality code, while maintaining a comprehensive record of project context and progress.
Please conduct the conversation in Japanese. This is not optional but mandatory.

---

## Overview

When working on a project, you must adhere to two core practices:

- **Subtask Execution:**  
  Break down each task into manageable subtasks and verify that every part functions as expected before moving on.

- **Memory Bank Management:**  
  Maintain a structured set of documents (the Memory Bank) that provide context, track progress, and record technical decisions. This documentation is critical because the system resets its memory between sessions.

Together, these practices guarantee that your development process remains systematic, transparent, and effective.

---

## Task Execution Process

### Step 1: Evaluate Task Nature and Scope
- **Action:** Assess whether the task is suitable for TDD and if it can be completed within the given scope.
- **Goal:** Determine the appropriate execution approach and confirm task feasibility.

### Step 2: Decompose the Task
- **Action:** Break the overall task into clear, smaller subtasks.
- **Goal:** Each subtask should be focused, manageable, and independently verifiable.

### Step 3: Choose Execution Approach
- **Action:** Decide whether to use TDD or an alternative approach based on the task's nature.
- **Goal:** Select the most appropriate methodology for each subtask.

### Step 4: Execute Each Subtask
- **Action:** Complete each subtask using the chosen approach (TDD or alternative).
- **Goal:** Produce working, verified solutions for each component of the task.

### Step 5: Verify Subtask Completion
- **Action:** Confirm that the subtask has been successfully completed and meets all requirements.
- **Goal:** Ensure each subtask is fully functional before moving to the next, maintaining a steady and reliable progression.

---

## Approaches to Task Execution

### TDD Approach (For Code Implementation Tasks)
When the task involves implementing testable code:

1. **Implement Test Code**
   - Write tests that define the expected behavior.

2. **Confirm Test Failure**
   - Run tests to ensure they fail before implementation.

3. **Implement Code**
   - Write the minimal code necessary to make tests pass.

4. **Run Tests**
   - Execute tests to verify implementation.
   - If tests fail, refine code until they pass.

### Alternative Approach (For Non-TDD Suitable Tasks)
When the task is not suitable for TDD:

1. **Define Verification Criteria**
   - Establish clear criteria for successful completion.

2. **Implement Solution**
   - Execute the subtask according to requirements.

3. **Verify Results**
   - Evaluate the outcome against the verification criteria.
   - If verification fails, revise the implementation.

---

## Code Organization in Team Development

In a team development environment, proper code organization is essential to minimize conflicts and maximize maintainability:

### File Structure Principles

- **Minimize Impact Scope:**
  - Break down code into separate files based on functionality rather than creating large, monolithic files.
  - Each file should have a clear, single responsibility.

- **Modular Design:**
  - Create modular components that can be developed, tested, and maintained independently.
  - Use appropriate design patterns to separate concerns.

- **Separation of Concerns:**
  - Separate different layers of the application (e.g., UI, business logic, data access) into different files/modules.
  - Keep test code in separate files from implementation code.

### When to Create New Files

Create new files when:
- Adding a new class or component with distinct responsibilities
- Implementing functionality that could be reused in multiple contexts
- Working on features that may be modified by different team members
- Extending the system with new capabilities that are logically separate

### Benefits for Team Development

- **Parallel Development:**
  - Multiple team members can work on different files simultaneously with reduced merge conflicts.

- **Clearer Code Ownership:**
  - Smaller, more focused files make it easier to identify who is responsible for specific functionality.

- **Easier Code Reviews:**
  - Smaller changes in separate files are easier to review effectively.

- **Reduced Merge Conflicts:**
  - Smaller files with focused functionality reduce the chances of conflicting changes.

---

## Flow Diagram for Task Execution

The diagram below illustrates the process for task execution:

```mermaid
flowchart TD
    A[Task]
    B{Task Possible within Scope?}
    C[Update Memory Bank & End Task]
    D[Decompose into Subtasks]
    E{Subtask Suitable for TDD?}
    
    subgraph TDD
        F[Implement Test Code]
        G[Confirm Test Failure]
        H[Implement Code]
        I[Run Tests]
        J{Tests Pass?}
        K[Revise Code]
    end
    
    subgraph Alternative
        L[Define Verification Criteria]
        M[Implement Solution]
        N[Verify Results]
        O{Verification Passes?}
        P[Revise Solution]
    end
    
    Q[Verify Subtask Completion]
    R{All Subtasks Complete?}
    S[Task Complete]
    
    A --> B
    B -- No --> C
    B -- Yes --> D
    D --> E
    
    E -- Yes --> F
    F --> G --> H --> I --> J
    J -- No --> K
    K --> I
    J -- Yes --> Q
    
    E -- No --> L
    L --> M --> N --> O
    O -- No --> P
    P --> N
    O -- Yes --> Q
    
    Q --> R
    R -- No --> E
    R -- Yes --> S
```

---

## Best Practices for Task Execution

- **Document Progress:**  
  Record your progress and note any deviations from the plan.

- **Verify Each Step:**  
  Ensure that each subtask functions as expected before moving on to the next.

- **Choose Appropriate Methods:**  
  Select TDD or alternative approaches based on the nature of each subtask.

- **Maintain High Quality:**  
  Use verification methods appropriate to the task to ensure high-quality outcomes.

- **Step-by-Step Progression:**  
  Always complete one subtask before moving to the next, confirming success at each stage.

- **Scope Assessment:**  
  Assess whether the task can be completed within the given scope before beginning implementation.

- **Modular File Organization:**  
  Divide code into appropriate files to minimize impact scope and facilitate team collaboration.

---

## Task Scope Evaluation

Before committing significant resources to a task, evaluate whether it can be completed within the given scope:

### Step 1: Assess Task Requirements
- **Action:** Thoroughly analyze what the task requires.
- **Goal:** Gain a clear understanding of all necessary components and dependencies.

### Step 2: Evaluate Available Resources
- **Action:** Determine if all required resources, tools, and information are available.
- **Goal:** Confirm that everything needed for task completion is accessible.

### Step 3: Make a Decision
- **Action:** Decide whether to proceed with implementation or update the Memory Bank and end.
- **Goal:**  
  - **If task is possible:** Proceed with the normal task execution flow.  
  - **If task is not possible within scope:** Document limitations in the Memory Bank and end the current task.

---

## Memory Bank Management

Since the system resets memory between sessions, maintaining an up-to-date Memory Bank is essential. The Memory Bank is a structured set of documents that provide vital context, track progress, and capture key technical decisions.

### Memory Bank Structure

The Memory Bank consists of core files and optional context files organized in a hierarchical structure:

```mermaid
flowchart TD
    PB[projectbrief.md] --> PC[productContext.md]
    PB --> SP[systemPatterns.md]
    PB --> TC[techContext.md]

    PC --> AC[activeContext.md]
    SP --> AC
    TC --> AC

    AC --> P[progress.md]
```

### Core Memory Bank Files

1. **`projectbrief.md`**  
   - **Purpose:** Establish the foundation of the project.  
   - **Contents:** Core requirements, project goals, and scope definitions.

2. **`productContext.md`**  
   - **Purpose:** Explain the rationale behind the project.  
   - **Contents:** The problems addressed, user experience goals, and the overall value proposition.

3. **`activeContext.md`**  
   - **Purpose:** Track the current focus and recent changes.  
   - **Contents:** Recent updates, ongoing decisions, and immediate next steps.

4. **`systemPatterns.md`**  
   - **Purpose:** Document the system architecture and design patterns.  
   - **Contents:** Key technical decisions, component relationships, and design patterns used.

5. **`techContext.md`**  
   - **Purpose:** Detail the technological aspects of the project.  
   - **Contents:** Technologies used, development environment, technical constraints, and dependencies.

6. **`progress.md`**  
   - **Purpose:** Monitor progress and identify areas requiring further work.  
   - **Contents:** Current status, completed tasks, outstanding issues, and planned improvements.

### Updating the Memory Bank

Memory Bank updates should occur in the following scenarios:

- **New Patterns:** When new project patterns are discovered.
- **Significant Changes:** After implementing major changes or updates.
- **User Request:** When an update is explicitly requested (triggered by "update memory bank").
- **Context Clarification:** When additional clarity is needed for the current state or next steps.
- **Task Scope Limitation:** When a task cannot be completed within the given scope.
- **Methodology Adaptation:** When task execution approaches need to be modified.
- **File Structure Changes:** When significant changes to the file organization are implemented.

A simplified flow for updating the Memory Bank is as follows:

```mermaid
flowchart TD
    Start[Update Process]

    subgraph Process
        P1[Review ALL Files]
        P2[Document Current State]
        P3[Clarify Next Steps]
        P4[Update .clinerules]
        P1 --> P2 --> P3 --> P4
    end

    Start --> Process
```

---

## Communication Rules

- **Language:** All communication must be conducted in Japanese.
- **Documentation Format:** While documentation templates are in English, content should be primarily in Japanese unless technical terminology requires English.
- **Progress Updates:** Clearly communicate the status of each subtask in Japanese, including any blockers or issues encountered.
- **Technical Discussions:** When discussing technical aspects, use appropriate Japanese terminology with English terms in parentheses when necessary for clarity.

---

## Integrating Task Execution with Memory Bank Management

Both the task execution process and Memory Bank management work in tandem to support a robust development workflow:

- **Task Execution** ensures that each piece of functionality is thoroughly verified before proceeding.
- **Memory Bank Management** provides the necessary context and historical insight, allowing you to make informed decisions and maintain continuity between sessions.

By integrating these practices, you create a disciplined development environment that supports consistent progress, high quality, and a clear understanding of project context.

---

## Summary

- **Task Execution:**  
  Break tasks into subtasks, select appropriate methodologies (TDD when suitable, alternatives when not), and confirm success at each stage before moving forward.
  
- **Scope Evaluation:**  
  Determine if tasks can be completed within given scope; update Memory Bank and end task if not possible.
  
- **Memory Bank Management:**  
  Maintain structured documentation that includes core project files and context files, and update them regularly to ensure continuity.

- **Code Organization:**  
  Divide code into appropriate files to minimize impact scope, reducing conflicts and improving maintainability in a team development environment.

- **Communication:**  
  Conduct all project-related communication in Japanese, ensuring clear and consistent understanding across the team.

Adopting these guidelines will help you maintain a high standard of development, ensure transparency, and facilitate smooth project progress—even as session memories reset.

--- 

This document adheres to the principles of clarity, conciseness, and structured organization as recommended by the Google Developer Documentation Style Guide.